Entrada e saída

 [exit-symbol.png]

Este capítulo descreve superficialmente as funções de entrada (= input) e de saída (= output) mais importantes da linguagem C.  Todas estão na biblioteca stdio. Para ter acesso a essa biblioteca, seu programa deve incluir a interface da biblioteca por meio de

#include <stdio.h>
Tela do monitor e teclado

A função  printf (= print formatted) exibe na tela do monitor uma lista formatada de números, caracteres, strings, etc.  O primeiro argumento da função é uma string que especifica o formato da impressão.

A função  scanf (= scan formatted) lê do teclado uma lista de números, caracteres, strings, etc.  O primeiro argumento da função é uma string que especifica o formato da lista a ser lida. Os demais argumentos são os endereços das variáveis onde os valores lidos devem ser armazenados.  A função trata todos os brancos como se fossem espaços. Veja um exemplo:

#include <stdio.h>
#include <stdlib.h>

int main (void) {
   int a, b;
   double media;
   scanf ("%d %d", &a, &b);
   media = (a + b)/2.0;
   printf ("A média de %d e %d é %f\n", a, b, media);
   return EXIT_SUCCESS;
}
Se o nome do programa for prog, veremos o seguinte resultado na tela (o computador escreve em vermelho e o usuário em azul):

prompt> ./prog
222 333
A média de 222 e 333 é 277.500000
prompt>
Arquivos

Um arquivo (= file) é uma sequência de bytes que reside na memória lenta do computador (um disco magnético, por exemplo). Abstratamente, um arquivo tem estrutura semelhante à memória RAM do computador. Mas, diferentemente da memória RAM, os bytes de um arquivo não podem ser endereçados individualmente. Assim, o acesso a um arquivo é estritamente sequencial: para chegar ao 5º byte é preciso passar pelo 1º, 2º, 3º e 4º bytes.

Para que um programa possa manipular um arquivo, é preciso associá-lo a uma variável do tipo  FILE  (esse tipo está definido na interface stdio.h).  A operação de associação é conhecida como abertura do arquivo e é executada pela função fopen (= file open). O primeiro argumento da função é o nome do arquivo e o segundo argumento é "r" ou "w" para indicar se o arquivo deve ser aberto para leitura (= read) ou para escrita (= write). A função fopen devolve o endereço de um FILE (ou NULL, se não encontrar o arquivo especificado).  Depois de usar o arquivo, é preciso fechá-lo com a função fclose (= file close).

Digamos, por exemplo, que o arquivo dados.txt contém uma sequência de números inteiros separados por brancos. O programa abaixo calcula a média desses números. Para ler o arquivo, o programa usa a função fscanf (= file scanf), que generaliza a função scanf:

#include <stdio.h>
#include <stdlib.h>
#define TRUE 1

int main (void) {
   int x, n, k;
   double soma;
   FILE *entrada;
   entrada = fopen ("dados.txt", "r");
   if (entrada == NULL) {
      printf ("\nNão encontrei o arquivo\n");
      exit (EXIT_FAILURE);
   }
   soma = n = 0;
   while (TRUE) {
      k = fscanf (entrada, "%d", &x);
      if (k != 1) break;
      soma += x;
      n += 1;
   }
   fclose (entrada);
   printf ("A média dos números é %f\n", soma/n);
   return EXIT_SUCCESS;
}
A função fscanf, tal como a função scanf, devolve o número de objetos efetivamente lidos. O programa acima usa isso para detectar o fim do arquivo.  (O programa supõe que o arquivo contém pelo menos um número.)

Stdin e stdout

O teclado é o arquivo padrão de entrada (= standard input).  Ele está permanente aberto e é representado pela constante stdin. Portanto fscanf (stdin, ...) equivale a scanf (...).

Algo análogo acontece com as funções printf, fprintf e o arquivo padrão de saída stdout, que representa a tela do monitor.

As funções fputc e fgetc

A função mais básica de saída — mais básica que printf e fprintf — é  fputc  (= put character).  Cada invocação da função grava um caractere no arquivo especificado.  Se c é um caractere e f aponta um arquivo, fputc (c, f) grava c no arquivo f.  Por exemplo, fputc ('#', stdout) exibe o caractere # na tela do monitor.

A função correspondente de leitura de caracteres é  fgetc  (= get character).  Cada chamada da função lê um caractere do arquivo especificado como argumento.  Por exemplo, fgetc (stdin) lê o próximo caractere do teclado.

Exemplo.  O programa abaixo lê uma linha de caracteres do teclado, armazena essa linha em um vetor e em seguida exibe esses caracteres na tela do monitor. O código supõe que a linha tem no máximo 100 caracteres (incluindo o '\n' final):

#include <stdio.h>
#include <stdlib.h>
#define TRUE 1

int main (void) {
   char linha[100];
   int i, n = 0;
   while (TRUE) {
      linha[n] = fgetc (stdin);
      if (linha[n] == '\n') break;
      n = n + 1;
   }
   for (i = 0; i <= n; i += 1)
      fputc (linha[i], stdout);
   return EXIT_SUCCESS;
}
Outro exemplo.  O programa abaixo lê o primeiro caractere do arquivo dados.txt e exibe esse caractere na tela do monitor:

#include <stdio.h>
#include <stdlib.h>

int main (void) {
   char c; // erro
   FILE *entrada;
   entrada = fopen ("dados.txt", "r");
   if (entrada == NULL) exit (EXIT_FAILURE);
   c = fgetc (entrada);
   fclose (entrada);
   fputc (c, stdout);
   return EXIT_SUCCESS;
}
Esse programa tem um defeito a ser discutido na próxima seção.

Que tipo de objeto fgetc devolve?

Que acontece se fgetc tenta ler o próximo caractere de um arquivo que já se esgotou?  Seria preciso que fgetc devolvesse algum tipo de caractere inválido, mas todos os 256 caracteres são válidos!

Para resolver esse impasse, fgetc devolve um int e não um caractere. O conjunto de valores int contém todos os valores de caracteres e mais alguns.  Assim, se o arquivo tiver se esgotado, fgetc pode devolver um inteiro diferente de qualquer caractere.  Mais especificamente,

se houver um próximo caractere no arquivo, fgetc lê o caractere como um unsigned char, transforma-o em um int positivo, e devolve o resultado;
se o arquivo não tiver mais caracteres, fgetc devolve um int estritamente negativo.
Para ser mais exato, se o arquivo não tiver mais caracteres, fgetc devolve a constante  EOF  (= end of file), que está definida na interface stdio.h e vale -1 na maioria dos computadores.

Resumindo, a resposta da função fgetc pertence a um superconjunto do conjunto em que estamos realmente interessados. Assim, a resposta é sempre do mesmo tipo, até em situações excepcionais.  Esse truque é uma boa lição de projeto.

Exemplo.  O seguinte fragmento de código exibe o próximo caractere do arquivo a menos que estejamos no fim do arquivo:

   int c;
   c = fgetc (entrada);
   if (c != EOF) 
      fputc (c, stdout);
   else 
      printf ("\nO arquivo terminou!");
(A propósito, se o arquivo de entrada for stdin, o fim do arquivo é produzido pela combinação de teclas Ctrl-D, que gera o caractere 4.)

Exercícios 1

Um programador propõe redefinir a função fgetc de modo que ela devolva um caractere (e não um int) e a expressão fgetc (entrada) tenha o seguinte efeito:  se não houver um próximo caractere no arquivo entrada, a função devolve o caractere '\a' (que não tem representaçao gráfica) e imprime a mensagem arquivo acabou na tela do monitor.  Critique essa proposta.
[!] Suponha que o arquivo dados.txt contém a sequência de caracteres  ABCÿDEF  e nada mais. O que o seguinte programa imprime?
int main (void) {
   FILE *entrada;
   int c;
   entrada = fopen ("dados.txt", "r");
   while ((c = fgetc (entrada)) != EOF)
      printf ("%c ", c);
   fclose (entrada);
   return EXIT_SUCCESS;
}
Que acontece se trocarmos int c por char c?   Que acontece se trocarmos int c por unsigned char c?

Escreva um programa completo que faça uma cópia byte-a-byte do arquivo cujo nome é digitado pelo usuário.  [Solução.]
Escreva um programa que remova os comentários (embrulhados em /* e */) do arquivo-fonte de um programa C.  O resultado deve ser gravado em um novo arquivo-fonte.
Argumentos na linha de comando

A execução de qualquer programa C começa pela função main.  Essa função admite dois parâmetros, que chamaremos numargs e arg.  O segundo parâmetro é um vetor e o primeiro é um inteiro que dá o número de elementos do vetor.  No seguinte exemplo, o vetor é arg[0..numargs-1]:

int main (int numargs, char *arg[]) {
   . . . 
} 
O valor de cada elemento de arg é uma string. Essas strings devem ser digitadas no terminal ao invocar o programa.  Elas passam a ser os dados do programa e são conhecidas como argumentos na linha de comando (= command-line arguments).  A primeira string digitada é o nome programa e passará a ser o valor de arg[0].  As strings seguintes serão os valores de arg[1], arg[2], etc., arg[numargs-1].  O valor de numargs é definido implicitamente pelo número de strings digitadas.

No seguinte exemplo, o nome do programa é prog.  Se digitarmos a linha de comando

prompt> ./prog -a  bb   ccc 2222
numargs assumirá o valor 5 e arg[0] a arg[4] serão as strings  "prog", "-a", "bb", "ccc" e "2222" respectivamente.

Exemplo.   O seguinte programa calcula a média dos números inteiros digitados na linha de comando:

#include <stdio.h>
#include <stdlib.h>

int main (int numargs, char *arg[]) {
   int soma, n;
   soma = 0;
   for (i = 1; i < numargs; ++i) 
      soma += atoi (arg[i]);
   n = numargs - 1;
   printf ("média = %.2f\n", (double) soma / n);
   return EXIT_SUCCESS;
} 
Se o nome do programa é prog, podemos ter a seguinte interação na tela do monitor:

prompt> ./prog +22   33 -11      +44
média = 22.00
prompt>
Outro exemplo.   O seguinte programa imprime uma tabela de conversão de graus Celsius em graus Fahrenheit ou vice-versa. O usuário especifica a direção da conversão, bem como o início e o fim da tabela.

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

/* Programa temperatura
// --------------------
// Para obter uma tabela de conversão de 
// graus Celsius em graus Fahrenheit, 
// digite
// 
//         ./temperatura c-f 10 40
//
// A primeira coluna começará com 10 graus 
// Celsius e andará em passos de 1 grau até 
// 40 graus Celsius. A segunda coluna trará 
// a correspondente temperatura em graus 
// Fahrenheit. Troque "c-f" por "f-c" para
// obter a tabela de conversão de graus 
// Fahrenheit em graus Celsius.
*/
int main (int numargs, char *arg[]) {
   int inf, sup;
   if (numargs != 4) {
      printf ("Número de argumentos errado.\n");
      return EXIT_FAILURE;
   }
   inf = atoi (arg[2]);
   sup = atoi (arg[3]);
   if (strcmp (arg[1], "c-f") == 0) {
      int c;
      printf ("Celsius Fahrenheit\n");
      for (c = inf; c <= sup; c += 1) 
         printf ("%7d %10.2f\n", c, 9.0/5.0*c + 32);
      return EXIT_SUCCESS;
   }
   if (strcmp (arg[1], "f-c") == 0) {
      int f;
      printf ("Fahrenheit  Celsius\n");
      for (f = inf; f <= sup; f += 1) 
         printf ("%10d %8.2f\n", f, 5.0*(f-32)/9.0);
      return EXIT_SUCCESS;
   }
   return EXIT_FAILURE;
} 
Exercícios 2

Escreva e teste um programa que imprima uma tabela com os valores de todos os argumentos que forem digitados pelo usuário na linha de comando e pare em seguida.
Word count.  Escreva um programa que conte o número de ocorrências de cada caractere em um arquivo. O programa deve receber o nome do arquivo pela linha de comando e imprimir uma tabela com o número de ocorrências de cada caractere.  (Para ganhar inspiração, analise o comportamento do utilitário wc.)
Perguntas e respostas
Pergunta:  Quando meu arquivo é exibido na tela do monitor, aparece um ^M no fim de cada linha. Por que?
Resposta:  Provavelmente o arquivo foi gerado no sistema Windows e está sendo exibido no sistema Linux. Nos sistemas Linux e UNIX, o fim de uma linha é indicado pelo caractere \n.  Já nos sistemas DOS e Windows, o fim de uma linha é indicado pelo par de caracteres \r\n, e o caractere \r aparece na tela como ^M